package org.wildfly.prospero.cli;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.MockitoJUnitRunner;
import org.wildfly.prospero.DistributionInfo;
import org.wildfly.prospero.Stability;
import org.wildfly.prospero.StabilityLevel;

import org.wildfly.prospero.cli.commands.AbstractCommand;
import org.wildfly.prospero.cli.commands.AbstractParentCommand;
import org.wildfly.prospero.cli.commands.CliConstants;
import org.wildfly.prospero.cli.commands.MainCommand;
import picocli.CommandLine;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

// Generated by Cursor
@RunWith(MockitoJUnitRunner.class)
public class StabilityAwareCommandBuilderTest {

    @Mock
    private ActionFactory actionFactory;

    @Mock
    private CliConsole console;

    private StabilityAwareCommandBuilder builder;
    private MockedStatic<DistributionInfo> distributionInfoMock;

    @Before
    public void setUp() {
        builder = new StabilityAwareCommandBuilder();
        distributionInfoMock = Mockito.mockStatic(DistributionInfo.class);
        distributionInfoMock.when(DistributionInfo::getStability).thenReturn(Stability.Default);
    }

    @After
    public void tearDown() {
        distributionInfoMock.close();
    }

    @Test
    public void testBasicCommandBuilding() {
        // Given
        MainCommand mainCommand = new MainCommand(console, actionFactory);

        // When
        CommandLine commandLine = builder.build(mainCommand);

        // Then
        assertThat(commandLine).isNotNull();
        assertEquals(DistributionInfo.DIST_NAME, commandLine.getCommandName());
    }

    @Test
    public void testCommandFilteringWithDefaultStability() {
        // Given
        distributionInfoMock.when(DistributionInfo::getStability).thenReturn(Stability.Default);
        BuildableCommand mainCommand = createTestMainCommand();

        // When
        CommandLine commandLine = builder.build(mainCommand);

        // Then
        Map<String, CommandLine> subcommands = commandLine.getSubcommands();
        assertTrue("Default command should be included", subcommands.containsKey("default-cmd"));
        assertFalse("Community command should be excluded", subcommands.containsKey("community-cmd"));
        assertFalse("Experimental command should be excluded", subcommands.containsKey("experimental-cmd"));
        assertTrue("Command without annotation should be included", subcommands.containsKey("no-annotation-cmd"));
    }

    @Test
    public void testCommandFilteringWithCommunityStability() {
        // Given
        distributionInfoMock.when(DistributionInfo::getStability).thenReturn(Stability.Community);
        BuildableCommand mainCommand = createTestMainCommand();

        // When
        CommandLine commandLine = builder.build(mainCommand);

        // Then
        Map<String, CommandLine> subcommands = commandLine.getSubcommands();
        assertTrue("Default command should be included", subcommands.containsKey("default-cmd"));
        assertTrue("Community command should be included", subcommands.containsKey("community-cmd"));
        assertFalse("Experimental command should be excluded", subcommands.containsKey("experimental-cmd"));
        assertTrue("Command without annotation should be included", subcommands.containsKey("no-annotation-cmd"));
    }

    @Test
    public void testCommandFilteringWithExperimentalStability() {
        // Given
        distributionInfoMock.when(DistributionInfo::getStability).thenReturn(Stability.Experimental);
        BuildableCommand mainCommand = createTestMainCommand();

        // When
        CommandLine commandLine = builder.build(mainCommand);

        // Then
        Map<String, CommandLine> subcommands = commandLine.getSubcommands();
        assertTrue("Default command should be included", subcommands.containsKey("default-cmd"));
        assertTrue("Community command should be included", subcommands.containsKey("community-cmd"));
        assertTrue("Experimental command should be included", subcommands.containsKey("experimental-cmd"));
        assertTrue("Command without annotation should be included", subcommands.containsKey("no-annotation-cmd"));
    }

    @Test
    public void testOptionFilteringWithDefaultStability() {
        // Given
        distributionInfoMock.when(DistributionInfo::getStability).thenReturn(Stability.Default);
        BuildableCommand mainCommand = createTestMainCommandWithOptions();

        // When
        CommandLine commandLine = builder.build(mainCommand);

        // Then
        CommandLine testCommand = commandLine.getSubcommands().get("test-options");
        List<String> optionNames = getOptionNames(testCommand.getCommandSpec());
        assertTrue("Default option should be included", optionNames.contains("--default-option"));
        assertFalse("Community option should be excluded", optionNames.contains("--community-option"));
        assertFalse("Experimental option should be excluded", optionNames.contains("--experimental-option"));
        assertTrue("Option without annotation should be included", optionNames.contains("--no-annotation"));
    }

    @Test
    public void testOptionFilteringWithCommunityStability() {
        // Given
        distributionInfoMock.when(DistributionInfo::getStability).thenReturn(Stability.Community);
        BuildableCommand mainCommand = createTestMainCommandWithOptions();

        // When
        CommandLine commandLine = builder.build(mainCommand);

        // Then
        CommandLine testCommand = commandLine.getSubcommands().get("test-options");
        List<String> optionNames = getOptionNames(testCommand.getCommandSpec());
        assertTrue("Default option should be included", optionNames.contains("--default-option"));
        assertTrue("Community option should be included", optionNames.contains("--community-option"));
        assertFalse("Experimental option should be excluded", optionNames.contains("--experimental-option"));
        assertTrue("Option without annotation should be included", optionNames.contains("--no-annotation"));
    }

    @Test
    public void testOptionFilteringWithExperimentalStability() {
        // Given
        distributionInfoMock.when(DistributionInfo::getStability).thenReturn(Stability.Experimental);
        BuildableCommand mainCommand = createTestMainCommandWithOptions();

        // When
        CommandLine commandLine = builder.build(mainCommand);

        // Then
        CommandLine testCommand = commandLine.getSubcommands().get("test-options");
        List<String> optionNames = getOptionNames(testCommand.getCommandSpec());
        assertTrue("Default option should be included", optionNames.contains("--default-option"));
        assertTrue("Community option should be included", optionNames.contains("--community-option"));
        assertTrue("Experimental option should be included", optionNames.contains("--experimental-option"));
        assertTrue("Option without annotation should be included", optionNames.contains("--no-annotation"));
    }

    @Test
    public void testStabilityLevelPermissions() {
        // Test the stability level logic directly
        assertTrue("Default should permit Default", Stability.Default.permits(Stability.Default));
        assertFalse("Default should not permit Community", Stability.Default.permits(Stability.Community));
        assertFalse("Default should not permit Experimental", Stability.Default.permits(Stability.Experimental));

        assertTrue("Community should permit Default", Stability.Community.permits(Stability.Default));
        assertTrue("Community should permit Community", Stability.Community.permits(Stability.Community));
        assertFalse("Community should not permit Experimental", Stability.Community.permits(Stability.Experimental));

        assertTrue("Experimental should permit all levels", Stability.Experimental.permits(Stability.Default));
        assertTrue("Experimental should permit all levels", Stability.Experimental.permits(Stability.Community));
        assertTrue("Experimental should permit all levels", Stability.Experimental.permits(Stability.Experimental));
    }

    @Test
    public void testCommandStructureIsBuilt() {
        // Given
        MainCommand mainCommand = new MainCommand(console, actionFactory);

        // When
        CommandLine commandLine = builder.build(mainCommand);

        // Then
        assertNotNull("CommandLine should be built", commandLine);
        Map<String, CommandLine> subcommands = commandLine.getSubcommands();

        // Verify that some expected subcommands exist (based on MainCommand constructor)
        assertTrue("Should have install command", subcommands.containsKey("install"));
        assertTrue("Should have update command", subcommands.containsKey("update"));
        assertTrue("Should have history command", subcommands.containsKey("history"));
    }

    @Test
    public void testNestedSubcommandStructure() {
        // Given
        MainCommand mainCommand = new MainCommand(console, actionFactory);

        // When
        CommandLine commandLine = builder.build(mainCommand);

        // Then
        Map<String, CommandLine> subcommands = commandLine.getSubcommands();

        // Test that nested commands are processed (e.g., update has prepare and perform subcommands)
        if (subcommands.containsKey("update")) {
            CommandLine updateCommand = subcommands.get("update");
            Map<String, CommandLine> updateSubcommands = updateCommand.getSubcommands();
            // The update command should have subcommands like prepare and perform
            assertFalse("Update command should have subcommands", updateSubcommands.isEmpty());
        }
    }

    @Test
    public void testExcludedParentCommandSkipsAllChildren() {
        // Given - A fearsome pirate scenario where the captain goes down with all hands!
        distributionInfoMock.when(DistributionInfo::getStability).thenReturn(Stability.Default);
        BuildableCommand mainCommand = createTestMainCommandWithExcludedParent();

        // When - We build the command structure, arrr!
        CommandLine commandLine = builder.build(mainCommand);

        // Then - Verify the experimental parent and all its crew are sent to Davy Jones' locker
        Map<String, CommandLine> subcommands = commandLine.getSubcommands();

        assertFalse("Experimental parent command should be excluded", subcommands.containsKey("experimental-parent"));
        assertFalse("Default child of experimental parent should also be excluded", subcommands.containsKey("default-child"));
        assertFalse("Community child of experimental parent should also be excluded", subcommands.containsKey("community-child"));

        // But verify other commands that should be included are still there, ye scallywag!
        assertTrue("Regular default command should still be included", subcommands.containsKey("default-cmd"));
    }

    @Test
    public void testStabilityOptionFilteringWithDefaultStability() {
        // Given - Distribution at Default stability level
        distributionInfoMock.when(DistributionInfo::getStability).thenReturn(Stability.Default);
        MainCommand mainCommand = new MainCommand(console, actionFactory);

        // When
        CommandLine commandLine = builder.build(mainCommand);

        // Then - The --stability option should be filtered out
        List<String> optionNames = getOptionNames(commandLine.getCommandSpec());
        assertFalse("--stability option should be excluded at Default stability level",
                   optionNames.contains(CliConstants.STABILITY));

        // But other options should still be present
        assertTrue("--help option should be included", optionNames.contains("--help"));
        assertTrue("--verbose option should be included", optionNames.contains("--verbose"));
    }

    @Test
    public void testStabilityOptionFilteringWithCommunityStability() {
        // Given - Distribution at Community stability level
        distributionInfoMock.when(DistributionInfo::getStability).thenReturn(Stability.Community);
        MainCommand mainCommand = new MainCommand(console, actionFactory);

        // When
        CommandLine commandLine = builder.build(mainCommand);

        // Then - The --stability option should be included
        List<String> optionNames = getOptionNames(commandLine.getCommandSpec());
        assertTrue("--stability option should be included at Community stability level",
                  optionNames.contains(CliConstants.STABILITY));
    }

    // Helper methods

    private BuildableCommand createTestMainCommand() {
        return new TestMainCommand();
    }

    private BuildableCommand createTestMainCommandWithOptions() {
        return new TestMainCommandWithOptions();
    }

    private BuildableCommand createTestMainCommandWithExcludedParent() {
        return new TestMainCommandWithExcludedParent();
    }

    private List<String> getOptionNames(CommandLine.Model.CommandSpec spec) {
        List<String> optionNames = new ArrayList<>();
        for (CommandLine.Model.OptionSpec option : spec.options()) {
            optionNames.addAll(Arrays.asList(option.names()));
        }
        return optionNames;
    }

    // Test command classes

    @CommandLine.Command(name = "test-main")
    public static class TestMainCommand extends AbstractParentCommand implements BuildableCommand {
        private List<AbstractCommand> subcommands;

        public TestMainCommand() {
            super(null, null, "test-main", new ArrayList<>());
            this.subcommands = Arrays.asList(
                new TestDefaultCommand(),
                new TestCommunityCommand(),
                new TestExperimentalCommand(),
                new TestNoAnnotationCommand()
            );
        }

        @Override
        public List<AbstractCommand> getSubcommands() {
            return subcommands;
        }
    }

    @CommandLine.Command(name = "test-main-with-options")
    public static class TestMainCommandWithOptions extends AbstractParentCommand implements BuildableCommand {
        private List<AbstractCommand> subcommands;

        public TestMainCommandWithOptions() {
            super(null, null, "test-main-with-options", new ArrayList<>());
            this.subcommands = Arrays.asList(new TestCommandWithOptions());
        }

        @Override
        public List<AbstractCommand> getSubcommands() {
            return subcommands;
        }
    }

    @CommandLine.Command(name = "test-main-with-excluded-parent")
    public static class TestMainCommandWithExcludedParent extends AbstractParentCommand implements BuildableCommand {
        private List<AbstractCommand> subcommands;

        public TestMainCommandWithExcludedParent() {
            super(null, null, "test-main-with-excluded-parent", new ArrayList<>());
            this.subcommands = Arrays.asList(
                new TestDefaultCommand(), // This should be included normally
                new TestExperimentalParentCommand() // This captain and crew should be excluded!
            );
        }

        @Override
        public List<AbstractCommand> getSubcommands() {
            return subcommands;
        }
    }

    @CommandLine.Command(name = "default-cmd")
    @StabilityLevel(level = Stability.Default)
    public static class TestDefaultCommand extends AbstractCommand {
        public TestDefaultCommand() {
            super(null, null);
        }

        @Override
        public Integer call() throws Exception {
            return 0;
        }
    }

    @CommandLine.Command(name = "community-cmd")
    @StabilityLevel(level = Stability.Community)
    public static class TestCommunityCommand extends AbstractCommand {
        public TestCommunityCommand() {
            super(null, null);
        }

        @Override
        public Integer call() throws Exception {
            return 0;
        }
    }

    @CommandLine.Command(name = "experimental-cmd")
    @StabilityLevel(level = Stability.Experimental)
    public static class TestExperimentalCommand extends AbstractCommand {
        public TestExperimentalCommand() {
            super(null, null);
        }

        @Override
        public Integer call() throws Exception {
            return 0;
        }
    }

    @CommandLine.Command(name = "no-annotation-cmd")
    public static class TestNoAnnotationCommand extends AbstractCommand {
        public TestNoAnnotationCommand() {
            super(null, null);
        }

        @Override
        public Integer call() throws Exception {
            return 0;
        }
    }

    @CommandLine.Command(name = "experimental-parent")
    @StabilityLevel(level = Stability.Experimental)
    public static class TestExperimentalParentCommand extends AbstractParentCommand implements BuildableCommand {
        private List<AbstractCommand> subcommands;

        public TestExperimentalParentCommand() {
            super(null, null, "experimental-parent", new ArrayList<>());
            this.subcommands = Arrays.asList(
                new TestDefaultChildCommand(), // Would normally be included, but parent is experimental
                new TestCommunityChildCommand() // Would normally be included, but parent is experimental
            );
        }

        @Override
        public List<AbstractCommand> getSubcommands() {
            return subcommands;
        }

        @Override
        public Integer call() throws Exception {
            return 0;
        }
    }

    @CommandLine.Command(name = "default-child")
    @StabilityLevel(level = Stability.Default)
    public static class TestDefaultChildCommand extends AbstractCommand {
        public TestDefaultChildCommand() {
            super(null, null);
        }

        @Override
        public Integer call() throws Exception {
            return 0;
        }
    }

    @CommandLine.Command(name = "community-child")
    @StabilityLevel(level = Stability.Community)
    public static class TestCommunityChildCommand extends AbstractCommand {
        public TestCommunityChildCommand() {
            super(null, null);
        }

        @Override
        public Integer call() throws Exception {
            return 0;
        }
    }

    @CommandLine.Command(name = "test-options")
    public static class TestCommandWithOptions extends AbstractCommand {
        @CommandLine.Option(names = "--default-option")
        @StabilityLevel(level = Stability.Default)
        private String defaultOption;

        @CommandLine.Option(names = "--community-option")
        @StabilityLevel(level = Stability.Community)
        private String communityOption;

        @CommandLine.Option(names = "--experimental-option")
        @StabilityLevel(level = Stability.Experimental)
        private String experimentalOption;

        @CommandLine.Option(names = "--no-annotation")
        private String noAnnotationOption;

        public TestCommandWithOptions() {
            super(null, null);
        }

        @Override
        public Integer call() throws Exception {
            return 0;
        }
    }
}